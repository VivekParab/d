# -*- coding: utf-8 -*-
"""ML2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10AvLOnnK141k9tkhnvh0T6WfxpoJSQzT
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv("/content/temperatures.csv")

df.shape

df.dtypes

df.isnull().sum()

df.columns

# input data
x = df['YEAR']

# output data
y = df['ANNUAL']
# y = df['JAN']

# plt.figure(figsize=(10,7))
print("Temperature of INDIA")
plt.xlabel('- YEAR -') # x-axis
plt.ylabel('- ANNUAL Temperature -') # y-axix
plt.scatter(x,y)

# there must be at least a single colum for it we are reshaping it
x.shape

x = x.values

x = x.reshape(117,1)

x.shape

from sklearn.linear_model import LinearRegression

regressor = LinearRegression()

# for training algorithm 'fit' method is used
# slope 'm'
regressor.fit(x,y)

# this is 'm' value from equation 'Y = mX + C'
regressor.coef_

# this is 'c' value from equation 'Y = mX + C'
# intercept 'c'
regressor.intercept_

regressor.predict([[2023]])

predicted = regressor.predict(x)

predicted

y

# Difference between actual and predicted is called MAE
import numpy as np

abs(y - predicted)

np.mean(abs(y - predicted))

# we can also use lib for calculating MAE
from sklearn.metrics import mean_absolute_error
mean_absolute_error(y, predicted)

# we can also use lib for calculating MSE
from sklearn.metrics import mean_squared_error
mean_squared_error(y, predicted)

# we can also use lib for calculating R - Square Error
from sklearn.metrics import r2_score
r2_score(y, predicted)

# drwing the best fit line
plt.xlabel('Year')
plt.ylabel('Annual Temperature')
plt.scatter(x, y, label = 'actual', color = 'r')
plt.plot(x, predicted, label = 'predicted', color = 'b')

# drawing the best fit line using seaborn lib
sns.regplot(x='YEAR', y='ANNUAL', data=df)

x1 = [3,4,5]

===========================================================================================================================
# -*- coding: utf-8 -*-
"""ML1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1txzQycchSYlZZMZCNAqZr3AFJinh5VsT
"""

# to perform structural data analysis
import pandas as pd

df = pd.read_csv("/content/Heart.csv")

df.head()

df.shape

# finding missing value
df.isnull()

df.isnull().sum()

# datatypes of each column
df.dtypes

# find out zeros
df == 0

df[df==0].count()

df.columns

# finding mean
df['Age'].mean()

# This is called label based slicing
newdf = df[['Age', 'Sex', 'ChestPain', 'RestBP', 'Chol']]

print(newdf)

# performing cross validation
# training and testing

from sklearn.model_selection import train_test_split

train, test = train_test_split(df, random_state=0, train_size=0.75)

train.shape

test.shape

import numpy as np

actual = np.concatenate((np.ones(45),np.zeros(450),np.ones(5)))

print(actual)

predicted = np.concatenate((np.ones(100),np.zeros(400)))

print(predicted)

# displaying confusion matrix
from sklearn.metrics import ConfusionMatrixDisplay

ConfusionMatrixDisplay.from_predictions(actual, predicted)

# importing lib for calculation
  # Accuracy
  # Precision
  # Recall
  # F-1 score
from sklearn.metrics import classification_report
from sklearn.metrics import accuracy_score

print(classification_report(actual, predicted))

accuracy_score(actual,predicted)

y1 = [5,3,1]

plt.xlabel=('X-axix')
plt.ylabel=('Y-axix')
plt.plot(x1, y1)
plt.show()
